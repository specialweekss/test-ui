# 视频接口实现说明

## 概述

挑战成功后需要播放视频，视频资源需要从服务器获取。如果服务器中没有对应的视频文件，前端会显示弹窗"视频不见了"并直接显示success图片。

## 接口规范

### 视频资源路径

**路径格式：**
```
/resources/assist/{challengeId}/success.mp4
```

**完整URL示例：**
```
http://localhost:8080/resources/assist/1/success.mp4
http://localhost:8080/resources/assist/2/success.mp4
http://localhost:8080/resources/assist/3/success.mp4
...
```

### 请求方式

**HTTP方法：** `GET`

**请求头：**
```
Accept: video/mp4
```

### 响应格式

#### 成功响应

**状态码：** `200 OK`

**响应头：**
```
Content-Type: video/mp4
Content-Length: {文件大小}
Accept-Ranges: bytes
```

**响应体：** 视频文件的二进制数据

#### 失败响应

**状态码：** `404 Not Found`（文件不存在）

**响应头：**
```
Content-Type: application/json
```

**响应体：**
```json
{
  "error": "Video not found",
  "message": "视频文件不存在"
}
```

## 实现方案

### 方案一：静态文件服务（推荐）

将视频文件作为静态资源存储在服务器上，通过静态文件服务直接提供访问。

#### 文件目录结构
```
服务器根目录/
├── resources/
│   └── assist/
│       ├── 1/
│       │   └── success.mp4
│       ├── 2/
│       │   └── success.mp4
│       ├── 3/
│       │   └── success.mp4
│       └── ...
```

#### Spring Boot 实现示例

**1. 配置文件（application.yml）**
```yaml
spring:
  web:
    resources:
      static-locations: classpath:/static/,file:./resources/
      chain:
        strategy:
          content:
            enabled: true
            paths: /**
```

**2. 静态资源配置类**
```java
@Configuration
public class StaticResourceConfig implements WebMvcConfigurer {
    
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 配置静态资源路径
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("file:./resources/")
                .setCachePeriod(3600); // 缓存1小时
    }
}
```

**3. 视频文件检查（可选）**
```java
@RestController
@RequestMapping("/resources")
public class VideoResourceController {
    
    @GetMapping("/assist/{challengeId}/success.mp4")
    public ResponseEntity<Resource> getVideo(@PathVariable Integer challengeId) {
        String videoPath = "resources/assist/" + challengeId + "/success.mp4";
        Path path = Paths.get(videoPath);
        
        if (!Files.exists(path)) {
            // 文件不存在，返回404
            return ResponseEntity.notFound().build();
        }
        
        try {
            Resource resource = new UrlResource(path.toUri());
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType("video/mp4"))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
                    .body(resource);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
```

### 方案二：数据库存储 + 文件系统

将视频文件信息存储在数据库中，实际文件存储在文件系统中。

#### 数据库表设计
```sql
CREATE TABLE video_resources (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    challenge_id INT NOT NULL COMMENT '挑战ID',
    file_path VARCHAR(255) NOT NULL COMMENT '文件路径',
    file_size BIGINT COMMENT '文件大小（字节）',
    mime_type VARCHAR(50) DEFAULT 'video/mp4' COMMENT 'MIME类型',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_challenge_id (challenge_id)
);
```

#### 实现示例
```java
@RestController
@RequestMapping("/resources")
public class VideoResourceController {
    
    @Autowired
    private VideoResourceService videoResourceService;
    
    @GetMapping("/assist/{challengeId}/success.mp4")
    public ResponseEntity<Resource> getVideo(@PathVariable Integer challengeId) {
        VideoResource videoResource = videoResourceService.getByChallengeId(challengeId);
        
        if (videoResource == null) {
            return ResponseEntity.notFound().build();
        }
        
        try {
            Path path = Paths.get(videoResource.getFilePath());
            if (!Files.exists(path)) {
                return ResponseEntity.notFound().build();
            }
            
            Resource resource = new UrlResource(path.toUri());
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(videoResource.getMimeType()))
                    .contentLength(videoResource.getFileSize())
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
                    .body(resource);
        } catch (Exception e) {
            log.error("获取视频失败: challengeId={}", challengeId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
```

### 方案三：对象存储服务（OSS）

将视频文件上传到对象存储服务（如阿里云OSS、腾讯云COS），通过CDN加速访问。

#### 实现示例（阿里云OSS）
```java
@RestController
@RequestMapping("/resources")
public class VideoResourceController {
    
    @Autowired
    private OssService ossService;
    
    @GetMapping("/assist/{challengeId}/success.mp4")
    public ResponseEntity<byte[]> getVideo(@PathVariable Integer challengeId) {
        String objectKey = "resources/assist/" + challengeId + "/success.mp4";
        
        try {
            // 从OSS获取文件
            OSSObject ossObject = ossService.getObject(objectKey);
            if (ossObject == null) {
                return ResponseEntity.notFound().build();
            }
            
            // 读取文件内容
            byte[] content = IOUtils.toByteArray(ossObject.getObjectContent());
            
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType("video/mp4"))
                    .contentLength(content.length)
                    .body(content);
        } catch (Exception e) {
            log.error("获取视频失败: challengeId={}", challengeId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
```

## 错误处理

### 404 处理

当视频文件不存在时，返回 `404 Not Found`。前端会检测到错误并显示弹窗"视频不见了"。

### 500 处理

当服务器内部错误时，返回 `500 Internal Server Error`。前端同样会显示弹窗"视频不见了"。

### 建议的错误响应格式

```json
{
  "error": "Video not found",
  "message": "挑战ID为 {challengeId} 的视频文件不存在",
  "challengeId": 1
}
```

## 性能优化建议

### 1. 启用缓存

```java
@GetMapping("/assist/{challengeId}/success.mp4")
public ResponseEntity<Resource> getVideo(@PathVariable Integer challengeId) {
    // ... 获取资源逻辑
    
    return ResponseEntity.ok()
            .cacheControl(CacheControl.maxAge(7, TimeUnit.DAYS)) // 缓存7天
            .eTag(etag) // ETag支持
            .lastModified(lastModified) // Last-Modified支持
            .body(resource);
}
```

### 2. 支持断点续传

```java
@GetMapping("/assist/{challengeId}/success.mp4")
public ResponseEntity<Resource> getVideo(
        @PathVariable Integer challengeId,
        @RequestHeader(value = "Range", required = false) String rangeHeader) {
    
    // 解析Range请求头
    if (rangeHeader != null && rangeHeader.startsWith("bytes=")) {
        // 实现206 Partial Content响应
        // ...
    }
    
    // 正常响应
    // ...
}
```

### 3. 使用CDN加速

如果视频文件较大，建议使用CDN加速，提高访问速度。

## 文件上传接口（可选）

如果需要通过接口上传视频文件，可以提供以下接口：

### 上传接口

**路径：** `POST /api/video/upload`

**请求格式：** `multipart/form-data`

**请求参数：**
- `challengeId`: 挑战ID（必填）
- `file`: 视频文件（必填，格式：mp4）

**响应示例：**
```json
{
  "success": true,
  "message": "视频上传成功",
  "data": {
    "challengeId": 1,
    "filePath": "resources/assist/1/success.mp4",
    "fileSize": 1024000,
    "url": "http://localhost:8080/resources/assist/1/success.mp4"
  }
}
```

## 测试建议

### 1. 正常情况测试

- 测试存在视频文件的请求，确保返回200和正确的视频内容
- 测试不同challengeId的视频文件

### 2. 异常情况测试

- 测试不存在的challengeId，确保返回404
- 测试文件损坏的情况，确保返回500
- 测试网络超时的情况

### 3. 性能测试

- 测试并发请求的性能
- 测试大文件的传输性能
- 测试断点续传功能

## 注意事项

1. **文件路径一致性**：确保服务器上的文件路径与接口路径一致
2. **文件格式**：视频文件必须是MP4格式
3. **文件大小**：建议控制视频文件大小，避免传输时间过长
4. **安全性**：如果视频文件包含敏感内容，需要添加权限验证
5. **跨域问题**：如果前端和服务器不在同一域名，需要配置CORS

## 总结

推荐使用**方案一（静态文件服务）**，实现简单，性能好，适合大多数场景。如果视频文件需要动态管理或存储在云端，可以使用方案二或方案三。

