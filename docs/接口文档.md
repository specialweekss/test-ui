# 游戏服务端接口文档

## 1. 微信登录接口

### 1.1 接口说明
通过微信小游戏的登录凭证 `code` 换取**自定义登录态（token）**，用于后续业务逻辑中前后端交互时识别用户身份。

**自定义登录态说明：**
- 自定义登录态是一个由服务器生成的唯一token（类似JWT）
- 服务器将 `openid` 和 `session_key` 存储在服务器端（数据库或缓存）
- 生成一个唯一的token返回给客户端
- 客户端后续请求时携带这个token
- 服务器通过token查找对应的 `openid`，从而识别用户身份

**为什么使用自定义登录态而不是直接返回openid：**
1. **安全性**：`openid` 和 `session_key` 不应该直接暴露给客户端
2. **灵活性**：可以在token中包含更多信息（过期时间、权限等）
3. **可控制性**：可以随时使token失效，而不影响 `openid`
4. **符合微信官方建议**：微信官方文档建议使用自定义登录态

### 1.2 接口地址
```
POST /api/game/wx-login
```

### 1.3 请求参数

#### 请求头
```
Content-Type: application/json
```

#### 请求体
```json
{
  "code": "微信登录凭证code（通过wx.login()获取）"
}
```

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| code | string | 是 | 微信登录凭证，由客户端调用 `wx.login()` 获取，有效期5分钟，只能使用一次 |

### 1.4 响应参数

#### 成功响应
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "token": "自定义登录态token",
    "expiresIn": 7200
  }
}
```

| 参数名 | 类型 | 说明 |
|--------|------|------|
| code | number | 响应状态码，200表示成功 |
| message | string | 响应消息，"success"表示成功 |
| data | object | 响应数据 |
| data.token | string | 自定义登录态token，客户端需要保存此token，后续所有请求都需要携带此token |
| data.expiresIn | number | token过期时间（秒），例如7200表示2小时后过期 |

#### 失败响应
```json
{
  "code": 400,
  "message": "错误信息描述",
  "data": null
}
```

| 状态码 | 说明 |
|--------|------|
| 400 | 请求参数错误（如code为空或无效） |
| 401 | 微信登录失败（如code已过期或已使用） |
| 500 | 服务器内部错误 |

### 1.5 业务流程

1. **客户端调用 `wx.login()`** 获取临时登录凭证 `code`
2. **客户端发送请求** 将 `code` 发送到服务器 `/api/game/wx-login`
3. **服务器调用微信API** 使用 `code` 调用微信 `code2Session` 接口
   - 接口地址：`https://api.weixin.qq.com/sns/jscode2session`
   - 请求参数：
     - `appid`: 小程序/小游戏的AppID
     - `secret`: 小程序/小游戏的AppSecret
     - `js_code`: 客户端传来的 `code`
     - `grant_type`: 固定值 `authorization_code`
4. **微信返回数据** 包含 `openid`、`session_key` 等
5. **服务器生成自定义登录态**
   - 将 `openid` 和 `session_key` 存储在服务器端（当前实现使用内存缓存，生产环境建议使用Redis）
   - 生成一个唯一的token（使用UUID方式）
   - 建立 token 与 `openid` 的映射关系，设置过期时间为2小时
6. **服务器返回给客户端** 将 `token` 返回给客户端（**不返回openid和session_key**）
7. **客户端保存token** 客户端需要将token保存到本地存储，后续所有请求都携带此token

### 1.6 微信 code2Session 接口说明

#### 请求示例
```
GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code
```

#### 成功响应
```json
{
  "openid": "用户唯一标识",
  "session_key": "会话密钥",
  "unionid": "用户在开放平台的唯一标识（如果小程序已绑定开放平台）"
}
```

#### 错误响应
```json
{
  "errcode": 40029,
  "errmsg": "invalid code"
}
```

常见错误码：
- `40029`: code无效（已过期或已使用）
- `45011`: 频率限制，每个用户每分钟100次
- `40163`: code已被使用

### 1.7 服务器端实现示例

#### Java (Spring Boot) 示例
```java
@RestController
@RequestMapping("/api/game")
public class GameController {
    
    @Value("${wechat.appid}")
    private String appid;
    
    @Value("${wechat.secret}")
    private String secret;
    
    @PostMapping("/wx-login")
    public ResponseEntity<Map<String, Object>> wxLogin(@RequestBody Map<String, String> request) {
        String code = request.get("code");
        
        if (code == null || code.isEmpty()) {
            return ResponseEntity.badRequest()
                .body(createErrorResponse(400, "code参数不能为空"));
        }
        
        try {
            // 调用微信 code2Session 接口
            String url = String.format(
                "https://api.weixin.qq.com/sns/jscode2session?appid=%s&secret=%s&js_code=%s&grant_type=authorization_code",
                appid, secret, code
            );
            
            RestTemplate restTemplate = new RestTemplate();
            String response = restTemplate.getForObject(url, String.class);
            
            // 解析响应
            ObjectMapper mapper = new ObjectMapper();
            Map<String, Object> wxResponse = mapper.readValue(response, Map.class);
            
            // 检查是否有错误
            if (wxResponse.containsKey("errcode")) {
                return ResponseEntity.status(401)
                    .body(createErrorResponse(401, "微信登录失败: " + wxResponse.get("errmsg")));
            }
            
            // 获取 openid 和 session_key
            String openid = (String) wxResponse.get("openid");
            String sessionKey = (String) wxResponse.get("session_key");
            if (openid == null || openid.isEmpty()) {
                return ResponseEntity.status(500)
                    .body(createErrorResponse(500, "未获取到openid"));
            }
            
            // 生成自定义登录态token（可以使用UUID、JWT等方式）
            String token = UUID.randomUUID().toString().replace("-", "");
            
            // 将 openid 和 session_key 存储在服务器端（数据库或Redis）
            // 建立 token 与 openid 的映射关系
            // 例如：redisService.set("token:" + token, openid, 7200); // 2小时过期
            // 或者：userTokenService.saveToken(token, openid, sessionKey);
            
            // 返回成功响应（只返回token，不返回openid和session_key）
            Map<String, Object> result = new HashMap<>();
            result.put("code", 200);
            result.put("message", "成功");
            Map<String, Object> data = new HashMap<>();
            data.put("token", token);
            data.put("expiresIn", 7200); // 2小时过期
            result.put("data", data);
            
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(createErrorResponse(500, "服务器内部错误: " + e.getMessage()));
        }
    }
    
    private Map<String, Object> createErrorResponse(int code, String message) {
        Map<String, Object> result = new HashMap<>();
        result.put("code", code);
        result.put("message", message);
        result.put("data", null);
        return result;
    }
}
```

#### Node.js (Express) 示例
```javascript
const express = require('express');
const axios = require('axios');
const router = express.Router();

const APPID = process.env.WECHAT_APPID;
const SECRET = process.env.WECHAT_SECRET;

router.post('/wx-login', async (req, res) => {
  const { code } = req.body;
  
  if (!code) {
    return res.status(400).json({
      code: 400,
      message: 'code参数不能为空',
      data: null
    });
  }
  
  try {
    // 调用微信 code2Session 接口
    const url = `https://api.weixin.qq.com/sns/jscode2session`;
    const params = {
      appid: APPID,
      secret: SECRET,
      js_code: code,
      grant_type: 'authorization_code'
    };
    
    const response = await axios.get(url, { params });
    const wxData = response.data;
    
    // 检查是否有错误
    if (wxData.errcode) {
      return res.status(401).json({
        code: 401,
        message: `微信登录失败: ${wxData.errmsg}`,
        data: null
      });
    }
    
    // 获取 openid 和 session_key
    const openid = wxData.openid;
    const sessionKey = wxData.session_key;
    if (!openid) {
      return res.status(500).json({
        code: 500,
        message: '未获取到openid',
        data: null
      });
    }
    
    // 生成自定义登录态token（可以使用UUID、JWT等方式）
    const crypto = require('crypto');
    const token = crypto.randomBytes(32).toString('hex');
    
    // 将 openid 和 session_key 存储在服务器端（数据库或Redis）
    // 建立 token 与 openid 的映射关系
    // 例如：await redis.set(`token:${token}`, openid, 'EX', 7200); // 2小时过期
    // 或者：await db.saveToken(token, openid, sessionKey);
    
    // 返回成功响应（只返回token，不返回openid和session_key）
    res.json({
      code: 200,
      message: '成功',
      data: {
        token: token,
        expiresIn: 7200 // 2小时过期
      }
    });
    
  } catch (error) {
    console.error('微信登录错误:', error);
    res.status(500).json({
      code: 500,
      message: `服务器内部错误: ${error.message}`,
      data: null
    });
  }
});

module.exports = router;
```

#### Python (Flask) 示例
```python
from flask import Flask, request, jsonify
import requests

app = Flask(__name__)

APPID = "your_appid"
SECRET = "your_secret"

@app.route('/api/game/wx-login', methods=['POST'])
def wx_login():
    data = request.get_json()
    code = data.get('code')
    
    if not code:
        return jsonify({
            'code': 400,
            'message': 'code参数不能为空',
            'data': None
        }), 400
    
    try:
        # 调用微信 code2Session 接口
        url = 'https://api.weixin.qq.com/sns/jscode2session'
        params = {
            'appid': APPID,
            'secret': SECRET,
            'js_code': code,
            'grant_type': 'authorization_code'
        }
        
        response = requests.get(url, params=params)
        wx_data = response.json()
        
        # 检查是否有错误
        if 'errcode' in wx_data:
            return jsonify({
                'code': 401,
                'message': f"微信登录失败: {wx_data.get('errmsg')}",
                'data': None
            }), 401
        
        # 获取 openid 和 session_key
        openid = wx_data.get('openid')
        session_key = wx_data.get('session_key')
        if not openid:
            return jsonify({
                'code': 500,
                'message': '未获取到openid',
                'data': None
            }), 500
        
        # 生成自定义登录态token（可以使用UUID、JWT等方式）
        import uuid
        token = str(uuid.uuid4()).replace('-', '')
        
        # 将 openid 和 session_key 存储在服务器端（数据库或Redis）
        # 建立 token 与 openid 的映射关系
        # 例如：redis.set(f'token:{token}', openid, ex=7200)  # 2小时过期
        # 或者：db.save_token(token, openid, session_key)
        
        # 返回成功响应（只返回token，不返回openid和session_key）
        return jsonify({
            'code': 200,
            'message': '成功',
            'data': {
                'token': token,
                'expiresIn': 7200  # 2小时过期
            }
        })
        
    except Exception as e:
        return jsonify({
            'code': 500,
            'message': f'服务器内部错误: {str(e)}',
            'data': None
        }), 500

if __name__ == '__main__':
    app.run(debug=True)
```

### 1.8 注意事项

1. **安全性**
   - `AppSecret` 必须保密，不能暴露在客户端代码中
   - `session_key` 不应该返回给客户端，只在服务器端使用
   - 建议对 `openid` 进行加密存储

2. **code 使用限制**
   - `code` 只能使用一次，使用后立即失效
   - `code` 有效期为5分钟，过期后需要重新获取
   - 如果 `code` 已使用或过期，微信会返回 `errcode: 40029`

3. **频率限制**
   - 每个用户每分钟最多调用100次
   - 超过限制会返回 `errcode: 45011`

4. **错误处理**
   - 必须处理网络请求失败的情况
   - 必须处理微信API返回的错误
   - 建议记录错误日志，便于排查问题

5. **数据库存储**
   - 将 `openid` 作为 `user_id` 存储在数据库中（**不存储token**）
   - 建议在数据库中为 `user_id` 字段建立唯一索引
   - 首次登录时创建用户记录，后续登录时更新登录时间
   - **token与openid的映射关系**应该存储在Redis或内存缓存中，设置过期时间（如2小时）
   - 当token过期后，客户端需要重新调用登录接口获取新token

6. **Token验证**
   - 所有需要身份验证的接口都需要验证token
   - 从请求头中获取token（`Authorization: Bearer {token}` 或 `X-Token: {token}`）
   - 通过token查找对应的openid
   - 如果token不存在或已过期，返回401未授权错误
   - 使用openid作为user_id查询或保存用户数据

### 1.9 测试用例

#### 正常流程测试
```bash
# 请求
curl -X POST http://your-server/api/game/wx-login \
  -H "Content-Type: application/json" \
  -d '{"code": "valid_code_from_wx_login"}'

# 预期响应
{
  "code": 200,
  "message": "成功",
  "data": {
    "token": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
    "expiresIn": 7200
  }
}
```

#### 错误测试 - code为空
```bash
# 请求
curl -X POST http://your-server/api/game/wx-login \
  -H "Content-Type: application/json" \
  -d '{"code": ""}'

# 预期响应
{
  "code": 400,
  "message": "code参数不能为空",
  "data": null
}
```

#### 错误测试 - code无效
```bash
# 请求
curl -X POST http://your-server/api/game/wx-login \
  -H "Content-Type: application/json" \
  -d '{"code": "invalid_code"}'

# 预期响应
{
  "code": 401,
  "message": "微信登录失败: invalid code",
  "data": null
}
```

---

## 2. 用户游戏数据接口

### 2.1 获取用户游戏数据

#### 接口地址
```
GET /api/game/user-data
```

#### 请求头
```
Authorization: Bearer {token}
```
或者
```
X-Token: {token}
```

#### 请求参数
**注意：此接口不需要URL参数或请求体参数，用户身份通过请求头中的token自动识别**

**说明：**
- 服务器通过token从缓存中查找对应的 `openid`（当前实现使用内存缓存，生产环境建议使用Redis）
- 使用 `openid` 作为 `user_id` 查询用户游戏数据
- 如果token不存在或已过期，返回401未授权错误

#### 响应参数

#### 成功响应
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "userId": "用户openid",
    "lastUpdateTime": "2024-01-01 12:00:00",
    "playerInfo": {
      "playerLevel": 1,
      "money": 0,
      "clickRewardBase": 100,
      "clickMultiplier": 1.0,
      "upgradeCost": 10,
      "trainingCount": 0
    },
    "assistants": [
      {
        "id": 1,
        "unlocked": false,
        "level": 0
      }
    ],
    "challenges": [
      {
        "id": 1,
        "completed": false
      }
    ]
  }
}
```

#### 失败响应
```json
{
  "code": 401,
  "message": "token无效或已过期",
  "data": null
}
```

| 状态码 | 说明 |
|--------|------|
| 200 | 成功 |
| 401 | token无效、已过期或未提供 |
| 500 | 服务器内部错误 |

### 2.2 保存用户游戏数据

#### 接口地址
```
POST /api/game/user-data
```

#### 请求头
```
Authorization: Bearer {token}
Content-Type: application/json
```
或者
```
X-Token: {token}
Content-Type: application/json
```

#### 请求参数
**重要：请求中不需要包含userId，服务器会根据token自动解析出openid作为userId**

```json
{
  "playerInfo": {
    "playerLevel": 1,
    "money": 0,
    "clickRewardBase": 100,
    "clickMultiplier": 1.0,
    "upgradeCost": 10,
    "trainingCount": 0
  },
  "assistants": [
    {
      "id": 1,
      "unlocked": false,
      "level": 0
    }
  ],
  "challenges": [
    {
      "id": 1,
      "completed": false
    }
  ]
}
```

**注意：**
- 请求体中的 `userId` 字段会被忽略，服务器使用token解析出的openid
- 如果请求体中包含 `userId` 字段，它将被服务器自动替换为token对应的openid

#### 响应参数

#### 成功响应
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "success": true,
    "lastUpdateTime": "2024-01-01 12:00:00"
  }
}
```

#### 失败响应
```json
{
  "code": 401,
  "message": "token无效或已过期",
  "data": null
}
```

| 状态码 | 说明 |
|--------|------|
| 200 | 成功 |
| 401 | token无效、已过期或未提供 |
| 500 | 服务器内部错误 |

### 2.3 服务器端实现示例

#### Java (Spring Boot) 示例

##### Token验证拦截器
```java
@Component
public class TokenInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 从请求头获取token
        String token = request.getHeader("X-Token");
        if (token == null || token.isEmpty()) {
            token = request.getHeader("Authorization");
            if (token != null && token.startsWith("Bearer ")) {
                token = token.substring(7);
            }
        }
        
        if (token == null || token.isEmpty()) {
            response.setStatus(401);
            response.setContentType("application/json;charset=UTF-8");
            response.getWriter().write("{\"code\":401,\"message\":\"token未提供\",\"data\":null}");
            return false;
        }
        
        // 从Redis中查找对应的openid
        String openid = redisTemplate.opsForValue().get("token:" + token);
        if (openid == null || openid.isEmpty()) {
            response.setStatus(401);
            response.setContentType("application/json;charset=UTF-8");
            response.getWriter().write("{\"code\":401,\"message\":\"token无效或已过期\",\"data\":null}");
            return false;
        }
        
        // 将openid存储到request属性中，供后续使用
        request.setAttribute("openid", openid);
        return true;
    }
}
```

##### 获取用户游戏数据接口
```java
@RestController
@RequestMapping("/api/game")
public class GameController {
    
    @Autowired
    private GameDataService gameDataService;
    
    @GetMapping("/user-data")
    public ResponseEntity<Map<String, Object>> getUserData(HttpServletRequest request) {
        // 从request属性中获取openid（由拦截器设置）
        String openid = (String) request.getAttribute("openid");
        
        try {
            // 根据openid查询用户游戏数据
            Map<String, Object> gameData = gameDataService.getUserGameData(openid);
            
            Map<String, Object> result = new HashMap<>();
            result.put("code", 200);
            result.put("message", "成功");
            result.put("data", gameData);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(createErrorResponse(500, "服务器内部错误: " + e.getMessage()));
        }
    }
    
    @PostMapping("/user-data")
    public ResponseEntity<Map<String, Object>> saveUserData(
            @RequestBody Map<String, Object> gameData,
            HttpServletRequest request) {
        // 从request属性中获取openid（由拦截器设置）
        String openid = (String) request.getAttribute("openid");
        
        try {
            // 根据openid保存用户游戏数据
            gameDataService.saveUserGameData(openid, gameData);
            
            Map<String, Object> result = new HashMap<>();
            result.put("code", 200);
            result.put("message", "成功");
            result.put("data", null);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(createErrorResponse(500, "服务器内部错误: " + e.getMessage()));
        }
    }
    
    private Map<String, Object> createErrorResponse(int code, String message) {
        Map<String, Object> result = new HashMap<>();
        result.put("code", code);
        result.put("message", message);
        result.put("data", null);
        return result;
    }
}
```

#### Node.js (Express) 示例

##### Token验证中间件
```javascript
const redis = require('redis');
const client = redis.createClient();

// Token验证中间件
const tokenAuth = async (req, res, next) => {
  // 从请求头获取token
  let token = req.headers['x-token'];
  if (!token) {
    const authHeader = req.headers['authorization'];
    if (authHeader && authHeader.startsWith('Bearer ')) {
      token = authHeader.substring(7);
    }
  }
  
  if (!token) {
    return res.status(401).json({
      code: 401,
      message: 'token未提供',
      data: null
    });
  }
  
  try {
    // 从Redis中查找对应的openid
    const openid = await client.get(`token:${token}`);
    if (!openid) {
      return res.status(401).json({
        code: 401,
        message: 'token无效或已过期',
        data: null
      });
    }
    
    // 将openid存储到request对象中，供后续使用
    req.openid = openid;
    next();
  } catch (error) {
    console.error('Token验证错误:', error);
    return res.status(500).json({
      code: 500,
      message: '服务器内部错误',
      data: null
    });
  }
};
```

##### 获取和保存用户游戏数据接口
```javascript
const express = require('express');
const router = express.Router();

// 获取用户游戏数据
router.get('/user-data', tokenAuth, async (req, res) => {
  try {
    const openid = req.openid; // 从中间件获取
    
    // 根据openid查询用户游戏数据
    const gameData = await db.getUserGameData(openid);
    
    res.json({
      code: 200,
      message: '成功',
      data: gameData
    });
  } catch (error) {
    console.error('获取用户游戏数据错误:', error);
    res.status(500).json({
      code: 500,
      message: `服务器内部错误: ${error.message}`,
      data: null
    });
  }
});

// 保存用户游戏数据
router.post('/user-data', tokenAuth, async (req, res) => {
  try {
    const openid = req.openid; // 从中间件获取
    const gameData = req.body;
    
    // 根据openid保存用户游戏数据
    await db.saveUserGameData(openid, gameData);
    
    res.json({
      code: 200,
      message: '成功',
      data: null
    });
  } catch (error) {
    console.error('保存用户游戏数据错误:', error);
    res.status(500).json({
      code: 500,
      message: `服务器内部错误: ${error.message}`,
      data: null
    });
  }
});

module.exports = router;
```

#### Python (Flask) 示例

##### Token验证装饰器
```python
from functools import wraps
import redis

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def token_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # 从请求头获取token
        token = request.headers.get('X-Token')
        if not token:
            auth_header = request.headers.get('Authorization')
            if auth_header and auth_header.startswith('Bearer '):
                token = auth_header[7:]
        
        if not token:
            return jsonify({
                'code': 401,
                'message': 'token未提供',
                'data': None
            }), 401
        
        try:
            # 从Redis中查找对应的openid
            openid = redis_client.get(f'token:{token}')
            if not openid:
                return jsonify({
                    'code': 401,
                    'message': 'token无效或已过期',
                    'data': None
                }), 401
            
            openid = openid.decode('utf-8')
            # 将openid存储到g对象中，供后续使用
            g.openid = openid
            return f(*args, **kwargs)
        except Exception as e:
            return jsonify({
                'code': 500,
                'message': f'服务器内部错误: {str(e)}',
                'data': None
            }), 500
    
    return decorated_function
```

##### 获取和保存用户游戏数据接口
```python
from flask import Flask, request, jsonify, g
from functools import wraps

app = Flask(__name__)

# 获取用户游戏数据
@app.route('/api/game/user-data', methods=['GET'])
@token_required
def get_user_data():
    try:
        openid = g.openid  # 从装饰器获取
        
        # 根据openid查询用户游戏数据
        game_data = db.get_user_game_data(openid)
        
        return jsonify({
            'code': 200,
            'message': '成功',
            'data': game_data
        })
    except Exception as e:
        return jsonify({
            'code': 500,
            'message': f'服务器内部错误: {str(e)}',
            'data': None
        }), 500

# 保存用户游戏数据
@app.route('/api/game/user-data', methods=['POST'])
@token_required
def save_user_data():
    try:
        openid = g.openid  # 从装饰器获取
        game_data = request.get_json()
        
        # 根据openid保存用户游戏数据
        db.save_user_game_data(openid, game_data)
        
        return jsonify({
            'code': 200,
            'message': '成功',
            'data': None
        })
    except Exception as e:
        return jsonify({
            'code': 500,
            'message': f'服务器内部错误: {str(e)}',
            'data': None
        }), 500
```

### 2.4 playerInfo 字段说明

| 字段名 | 类型 | 必填 | 说明 | 默认值 |
|--------|------|------|------|--------|
| playerLevel | number | 是 | 玩家等级 | 1 |
| money | number | 是 | 当前金钱 | 0 |
| clickRewardBase | number | 是 | 点击收益基础值 | 100 |
| clickMultiplier | number | 是 | 点击收益倍率 | 1.0 |
| upgradeCost | number | 是 | 升级所需金币 | 10 |
| trainingCount | number | 是 | 助理培训次数（基础收益倍率 = 2的trainingCount次方） | 0 |

**重要说明：**
- `trainingCount` 表示玩家进行助理培训的次数
- 基础收益倍率计算公式：`基础收益倍率 = 2^trainingCount`
- 例如：`trainingCount = 0` 时，基础收益倍率为 `2^0 = 1`（即100%）
- 例如：`trainingCount = 3` 时，基础收益倍率为 `2^3 = 8`（即800%）
- 最终点击收益 = `clickRewardBase * 2^trainingCount * clickMultiplier`

### 2.5 Token验证流程

1. **客户端发送请求**：在请求头中携带token（`X-Token` 或 `Authorization: Bearer {token}`）
2. **服务器验证token**：
   - 从请求头中提取token
   - 在Redis或缓存中查找 `token:{token}` 对应的 `openid`
   - 如果token不存在或已过期，返回401错误
3. **获取用户数据**：
   - 使用 `openid` 作为 `user_id` 查询或保存用户游戏数据
4. **返回响应**：返回处理结果

### 2.6 错误处理

#### Token相关错误
- **401 - token未提供**：请求头中没有token
- **401 - token无效或已过期**：token在Redis中不存在或已过期
- **500 - 服务器内部错误**：Redis连接失败或其他服务器错误

#### 处理建议
1. **Token过期处理**：客户端收到401错误时，应该重新调用登录接口获取新token
2. **自动重试**：可以实现自动重试机制，当token过期时自动重新登录
3. **错误提示**：向用户显示友好的错误提示信息

### 2.7 测试用例

#### 获取用户游戏数据测试
```bash
# 正常请求
curl -X GET http://your-server/api/game/user-data \
  -H "X-Token: your_token_here"

# 预期响应
{
  "code": 200,
  "message": "成功",
  "data": {
    "playerInfo": {...},
    "assistants": [...],
    "challenges": [...]
  }
}

# Token无效测试
curl -X GET http://your-server/api/game/user-data \
  -H "X-Token: invalid_token"

# 预期响应
{
  "code": 401,
  "message": "token无效或已过期",
  "data": null
}

# 未提供Token测试
curl -X GET http://your-server/api/game/user-data

# 预期响应
{
  "code": 401,
  "message": "token未提供",
  "data": null
}
```

#### 保存用户游戏数据测试
```bash
# 正常请求
curl -X POST http://your-server/api/game/user-data \
  -H "X-Token: your_token_here" \
  -H "Content-Type: application/json" \
  -d '{
    "playerInfo": {
      "playerLevel": 1,
      "money": 0,
      "clickRewardBase": 100,
      "clickMultiplier": 1.0,
      "upgradeCost": 10,
      "trainingCount": 0
    },
    "assistants": [...],
    "challenges": [...]
  }'

# 预期响应
{
  "code": 200,
  "message": "成功",
  "data": null
}
```

---

## 3. 配置说明

### 3.1 微信小程序/小游戏配置

需要在微信公众平台获取以下信息：
- **AppID**: 小程序/小游戏的唯一标识
- **AppSecret**: 小程序/小游戏的密钥

### 3.2 服务器配置

建议使用环境变量或配置文件存储敏感信息：
```bash
# 环境变量示例
WECHAT_APPID=your_appid
WECHAT_SECRET=your_secret
```

---

## 4. 数据库设计建议

### 4.1 用户表结构

```sql
CREATE TABLE `user_game_data` (
  `user_id` VARCHAR(64) PRIMARY KEY COMMENT '用户唯一标识（openid）',
  `player_level` INT DEFAULT 1 COMMENT '玩家等级',
  `money` BIGINT DEFAULT 0 COMMENT '当前金钱',
  `click_reward_base` INT DEFAULT 100 COMMENT '点击收益基础值',
  `click_multiplier` DECIMAL(10,2) DEFAULT 1.0 COMMENT '点击收益倍率',
  `upgrade_cost` INT DEFAULT 10 COMMENT '升级所需金币',
  `training_count` INT DEFAULT 0 COMMENT '助理培训次数（基础收益倍率 = 2的trainingCount次方）',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  INDEX `idx_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户游戏数据表';

CREATE TABLE `user_assistants` (
  `id` BIGINT AUTO_INCREMENT PRIMARY KEY,
  `user_id` VARCHAR(64) NOT NULL COMMENT '用户唯一标识（openid）',
  `assistant_id` INT NOT NULL COMMENT '助理ID',
  `unlocked` TINYINT(1) DEFAULT 0 COMMENT '是否已解锁',
  `level` INT DEFAULT 0 COMMENT '当前等级',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY `uk_user_assistant` (`user_id`, `assistant_id`),
  INDEX `idx_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户助理数据表';

CREATE TABLE `user_challenges` (
  `id` BIGINT AUTO_INCREMENT PRIMARY KEY,
  `user_id` VARCHAR(64) NOT NULL COMMENT '用户唯一标识（openid）',
  `challenge_id` INT NOT NULL COMMENT '挑战ID',
  `completed` TINYINT(1) DEFAULT 0 COMMENT '是否已完成',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY `uk_user_challenge` (`user_id`, `challenge_id`),
  INDEX `idx_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户挑战数据表';
```

### 4.2 Token存储

**当前实现：**
- Token与openid的映射关系存储在内存缓存中（ConcurrentHashMap）
- 定时清理过期token（每小时清理一次）
- Token过期时间：7200秒（2小时）

**生产环境建议：**
- 使用Redis存储token与openid的映射关系
- Redis Key格式：`token:{token}`
- Redis Value：`{openid}`
- TTL：7200秒（2小时）

示例：
```
token:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 -> oUpF8uMuAJO_M2pxb1Q9zNjWeS6o
```

### 4.3 数据查询逻辑

1. **获取用户游戏数据**：
   - 根据 `openid` 查询 `user_game_data` 表
   - 根据 `openid` 查询 `user_assistants` 表
   - 根据 `openid` 查询 `user_challenges` 表
   - 组装返回数据

2. **保存用户游戏数据**：
   - 根据 `openid` 更新或插入 `user_game_data` 表
   - 根据 `openid` 批量更新或插入 `user_assistants` 表
   - 根据 `openid` 批量更新或插入 `user_challenges` 表

---

## 5. 更新日志

### v1.3.0 (2024-01-XX)
- **新增字段**：`playerInfo.trainingCount` - 助理培训次数（基础收益倍率）
- **数据库变更**：`user_game_data` 表新增 `training_count` 字段
- **接口更新**：获取和保存用户游戏数据接口支持 `trainingCount` 字段
- **说明**：基础收益倍率计算公式为 `2^trainingCount`，影响最终点击收益计算

### v1.2.0 (2024-01-XX)
- **已实现**：微信登录接口 `/api/game/wx-login`
- **已实现**：Token验证拦截器，自动验证请求头中的token
- **已修改**：用户游戏数据接口，移除userId参数，改为通过token验证自动获取openid
- **已实现**：使用内存缓存存储token与openid的映射关系（生产环境建议使用Redis）
- **已更新**：接口文档，反映实际实现细节

### v1.1.0 (2024-01-XX)
- 更新接口使用自定义登录态token验证
- 移除接口中的userId参数，改为通过token验证获取openid
- 添加完整的服务器端实现示例（Java、Node.js、Python）
- 添加Token验证中间件/拦截器示例
- 添加数据库设计建议

### v1.0.0 (2024-01-XX)
- 初始版本
- 实现微信登录接口
- 实现用户游戏数据接口

